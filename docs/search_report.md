Cloudflare Workers/PagesからGCPへの移行戦略：Hono.js APIとVite+React静的サイトの最適構成評価1. はじめに1.1. ユーザーの現状構成現在、ユーザーはHono.jsフレームワークで構築されたAPIをCloudflare Workers上で、ViteとReactを用いて開発された静的ウェブサイトをCloudflare Pages上で運用しています。この構成は、Workersによるエッジコンピューティングの活用と、Pagesに統合されたCDNおよびSSL機能による効率的な静的コンテンツ配信を特徴としています 1。1.2. 移行の目的本レポートの目的は、このフルスタックアプリケーションをGoogle Cloud Platform (GCP) へ移行するにあたり、最適なサービス構成を特定することです。1.3. レポートのスコープと構成本レポートでは、ユーザーが提示した8つの具体的な要件に基づき、GCP上でHono.js APIおよびVite+React静的サイトをホストするための主要なサービスオプションを評価・比較します。具体的には、APIの移行先としてCloud Functions (Gen 2 / Cloud Run Functions) とCloud Runを、静的サイトの移行先としてCloud Storage + Cloud CDN (+ Load Balancer) とFirebase Hostingを詳細に分析します。App Engineについても代替案として簡単に触れますが、ユーザーの関心がCloud FunctionsとCloud Runに集中していることを考慮し、本レポートではこれら2つのサービスに焦点を当てます。各セクションでは、互換性、機能、コスト、スケーラビリティ、移行の容易さ、運用負荷といった観点から各サービスを評価し、最終的にユーザーの現在の構成からの移行に最適なGCPサービスの組み合わせを提案します。2. Hono.js API移行のためのGCPコンピューティングオプション2.1. 概要Hono.jsのようなNode.jsベースのAPIをGCPに移行する際に検討すべき主要なサーバーレス/コンテナコンピューティングオプションは、Cloud Functions (特にGen 2、Cloud Run Functionsとも呼ばれる) とCloud Runです。App Engine Standard/Flexも選択肢となり得ますが、Cloudflare Workersのようなエッジ関数環境から移行する場合、FaaS (Function-as-a-Service) やコンテナベースのマネージドプラットフォームであるCloud FunctionsやCloud Runの方が、パラダイムが近く、スケーリングや料金体系の面でより現代的なステートレスAPIに適していると考えられます。2.2. サービス詳細：Cloud Functions (Gen 2 / Cloud Run Functions)
コアコンセプト: Cloud Functionsは、イベント駆動型のFunction-as-a-Service (FaaS) であり、ソースコードから直接デプロイでき、コンテナ管理を抽象化します 3。単一目的の関数やシンプルなAPIの実行に適しています 3。第2世代はCloud Runのインフラストラクチャ上に構築されています 4。
Node.js/Hono.js互換性: 標準的なNode.jsランタイムをサポートしています 7。Hono.jsは、@hono/node-serverアダプタを使用することでCloud Functions上で実行可能です 9。HonoのようなWebフレームワークを使用する場合、GCP Functions Frameworkの役割は限定的になる可能性があります。Functions FrameworkはGCP Functions向けのコード構造化を支援しますが 10、Honoは自身のNode.jsアダプタ (@hono/node-server) を介してHTTPリクエスト/レスポンスを処理するため 9、HTTPエンドポイント用途においてはFunctions FrameworkのHTTP処理機能は冗長になる可能性があります 12。イベントトリガー連携では依然として有用かもしれませんが、APIエンドポイントとしてはHonoアダプタが中心的な役割を担うため、依存関係がシンプルになる可能性があります。
スケーラビリティ: リクエストに基づいてゼロから自動的にスケールします 4。ただし、コールドスタートによるレイテンシの影響を受ける可能性があります。
料金体系: 呼び出し回数、コンピューティング時間 (GB秒、GHz秒)、およびアウトバウンドネットワークに基づいて課金されます 13。無料利用枠も提供されています 13。利用パターンによってはCloud Runと比較してコストが高くなる可能性があります 6。
2.3. サービス詳細：Cloud Run
コアコンセプト: ステートレスコンテナを実行するためのマネージドプラットフォームです 3。コンテナ化されたあらゆるアプリケーション (任意の言語、ライブラリ、バイナリ) を実行でき、ランタイム環境に対するより詳細な制御を提供します 4。Webサービス、API、マイクロサービスに適しています 3。
Node.js/Hono.js互換性: コンテナ内で任意のNode.jsバージョンを実行できます 3。Hono.jsは、コンテナ内のNode.js環境で@hono/node-serverアダプタを使用してシームレスに動作します 9。ソースコードから直接デプロイ (Buildpacksが自動的にコンテナ化) するか、事前にビルドされたコンテナイメージからデプロイできます 3。
スケーラビリティ: リクエストまたはCPU使用率に基づいて、ゼロ (または設定された最小インスタンス数) から自動的にスケールします 4。Cloud Functionsよりも多くのスケーリング構成オプション (同時実行数、最小/最大インスタンス数) を提供します 4。
料金体系: vCPU秒、メモリ秒、リクエスト数、およびアウトバウンドネットワークに基づいて課金されます 18。持続的なトラフィックや高トラフィックの場合、一般的にCloud Functionsよりもコスト効率が高いと考えられています 6。無料利用枠も存在します。
2.4. 比較表：Hono.js API向けCloud Functions vs. Cloud Run
特徴項目Cloud Functions (Gen 2)Cloud Run基本概念FaaS、イベント駆動、コンテナ管理の抽象化 3マネージドコンテナプラットフォーム、ステートレス 3制御レベル低 (ランタイム選択肢に制限) 4高 (任意のコンテナ、言語、ライブラリ) 4デプロイ単位関数コード 3コンテナイメージ 3ソースデプロイ標準 (Functions Framework利用) 3可能 (Buildpacksによる自動コンテナ化) 3カスタムランタイム不可 6可能 (Dockerfile経由) 16Node.js/Hono互換性サポート (Node.jsランタイム + @hono/node-server) 7サポート (コンテナ内Node.js + @hono/node-server) 3スケーラビリティ自動 (ゼロから)、設定限定 4自動 (ゼロまたは最小インスタンスから)、詳細設定可 (同時実行数、min/max) 4コールドスタート可能性あり最小インスタンス設定で軽減可能 14料金モデル呼び出し回数、コンピューティング時間、ネットワーク 13vCPU/メモリ秒、リクエスト数、ネットワーク 18コストプロファイル低トラフィックで有利な可能性、高トラフィックで割高になる可能性 6高トラフィック/持続的負荷で有利な可能性 6運用負荷低 (コード中心、インフラ管理不要) 4中 (コンテナ意識必要、ソースデプロイで軽減可) 4
この比較表は、ユーザーが自身の優先順位（例えば、シンプルさ、制御性、コスト）に基づいて、Cloud FunctionsとCloud RunのどちらがHono.js APIの移行先として適しているかを判断する一助となります。3. Vite+React静的サイトホスティングのためのGCPオプション3.1. 概要ViteとReactのようなフレームワークで構築された静的ウェブサイトをGCPでホスティングする際の主要な選択肢は、Cloud Storage (通常、Cloud CDNおよびロードバランサーと組み合わせる) とFirebase Hostingです。3.2. サービス詳細：Cloud Storage + Cloud CDN (+ Load Balancer)
コアコンセプト: Cloud Storageバケットを使用して静的ファイル (HTML, CSS, JS, 画像など) を保存します 20。Cloud CDNを利用して、グローバルなコンテンツキャッシュと配信高速化を実現します 23。Cloud CDNの使用、および特にカスタムドメインでのHTTPS配信には、Global External Application Load Balancerが必要です 21。
特徴: ストレージクラス 27、CDNキャッシュ動作 (ヘッダーまたはCDNポリシー経由) 24、ロードバランシングルールに対する詳細な制御が可能です。Googleのネットワークを活用した高いスケーラビリティとパフォーマンスを提供します 20。
デプロイ容易性: バケットへの手動アップロードまたはスクリプト (gsutil、クライアントライブラリ) が必要です 20。バケット権限、CDNバックエンド、ロードバランサー (フロントエンド、バックエンド、SSL証明書) の個別設定が求められ、Firebase Hostingと比較して設定が複雑です 21。
CDN機能: Googleのグローバルエッジネットワークを活用します 20。キャッシュポリシーを設定可能です 24。キャッシュ無効化も利用できます 24。
SSL: カスタムドメインでのSSL証明書 (Googleマネージドまたは自己管理) にはロードバランサーが必須です 21。Cloud Storageの直接ホスティングでは、カスタムドメインのHTTPまたは storage.googleapis.com URL経由のHTTPSのみサポートされます 22。
料金体系: Cloud Storageのコスト (ストレージ、オペレーション、キャッシュミス時のネットワーク下り) 27、Cloud CDNのコスト (キャッシュ下り、キャッシュフィル、ルックアップリクエスト) 23、およびロードバランサーのコスト (転送ルール最小料金、データ処理) 25 の組み合わせとなります。大規模なトラフィックではFirebaseよりも下り転送料金が安くなる可能性がありますが 33、低トラフィックサイトではロードバランサーの固定費が影響します 32。
3.3. サービス詳細：Firebase Hosting
コアコンセプト: 静的および動的ウェブコンテンツ、マイクロサービス向けに最適化されたフルマネージドホスティングサービスです 35。GCPインフラストラクチャ上に構築され、グローバルCDNが含まれます 35。
特徴: Firebase CLIによる簡素化されたデプロイ 37、自動グローバルCDN、カスタムドメインに対する無料の自動SSL 32、バージョンロールバック、プレビューチャネル、他のFirebaseサービスおよびGCPとの統合 35 を提供します。プロジェクトごとに複数のサイトをサポートします 35。
デプロイ容易性: Firebase CLI (firebase deploy) を使用して非常に簡単に行えます 38。CI/CDパイプラインとの統合も容易です 32。firebase.json での最小限の設定が必要です 42。CS+CDN+LBよりも設定が簡単です 32。
CDN機能: グローバルCDNがデフォルトで含まれており、追加設定は不要です 35。キャッシュ動作は firebase.json で設定された Cache-Control ヘッダーを通じて制御できます 43。
SSL: Firebaseサブドメインとカスタムドメインの両方に対して、無料のSSL証明書が自動的にプロビジョニングされ、更新されます 32。HTTPSのために別途ロードバランサーは不要です。
料金体系: 寛大な無料利用枠 (ストレージ10GB、データ転送10GB/月) があります 37。有料 (Blaze) プランでは、無料枠を超えた使用量に対して課金されます：ストレージ ($0.026/GB)、データ転送 ($0.15/GB) 37。非常に大量のトラフィックではCloud CDNよりも下り転送コストが高くなる可能性がありますが 44、ロードバランサーの固定費はかかりません 32。
3.4. 比較表：静的サイト向けCloud Storage + CDN vs. Firebase Hosting
特徴項目Cloud Storage + Cloud CDN (+ LB)Firebase Hostingマネージドレベル低 (複数コンポーネントの手動設定・管理) 21高 (フルマネージドサービス) 35CDN統合手動設定が必要 21自動的に統合、設定不要 35SSL処理カスタムドメインにはLB必須 21カスタムドメイン含め自動・無料 32カスタムドメインサポート (LB経由でHTTPS) 22サポート (自動HTTPS) 35デプロイ方法手動アップロード/スクリプト (gsutil) 20Firebase CLI (firebase deploy) 38ロールバック/プレビュー手動実装が必要標準機能として提供 35デプロイ容易性高 (複数サービス設定) 29低 (CLI中心、設定ファイル最小限) 32CDNキャッシュ制御ヘッダー/CDNポリシーで詳細設定可 24firebase.json のヘッダーで制御 43キャッシュ無効化可能 24(明示的な機能はないが、デプロイで更新)料金モデル複数サービスの組み合わせ (Storage+CDN+LB) 23シンプル (Storage+Transfer) 37無料利用枠各サービスに依存 (CDNはなし)寛大 (Storage 10GB, Transfer 10GB/月) 37コストドライバーLB固定費、CDN下り/フィル、Storageオペレーション 23無料枠超過後のStorage/Transfer 37コストプロファイル高トラフィックで有利な可能性、低トラフィックではLBコストが影響 32低～中トラフィックで有利、超高トラフィックで割高になる可能性 32GCP/Firebase統合ネイティブGCPサービスFirebaseエコシステムとシームレス、GCPプロジェクトと統合 35
この比較は、開発者の運用負荷、初期コスト、将来のスケーラビリティといった要因を考慮して、静的サイトのホスティング戦略を決定する上で役立ちます。4. 評価：Hono.js API向けCloud Functions4.1. メリット
シンプルさ: コードに集中でき、インフラ管理は最小限で済みます 4。シンプルなイベント駆動ロジックには最も簡単なエントリーポイントです 4。
迅速なデプロイ: ソースコードから直接、迅速にデプロイできます 7。
統合: GCPのイベントソース (Pub/Sub, Storageトリガー, Eventarc) との強力な統合を提供します 4。
4.2. デメリット
制御の制限: Cloud Runと比較してランタイム環境の制御が制限されます 4。サポートされているランタイムに限定されます 6。
潜在的なコールドスタート: 頻繁に呼び出されないAPIでは、コールドスタートが発生し、レイテンシに影響を与える可能性があります。
ステートレス性/タイムアウト: 短命でステートレスな操作向けに設計されています (Gen 2はGen 1よりタイムアウトが長いですが、Runと比較すると依然として制限があります) 6。
スケール時のコスト: 高スループットのAPIでは、呼び出しベースの課金がCloud Runよりも高価になる可能性があります 6。
4.3. 設定とセットアップ
@hono/node-server アダプタが必要です 9。
gcloud functions deploy コマンドを使用して、エントリーポイント、ランタイム、トリガーを指定してデプロイします 7。
環境変数とシークレットは、Cloud Functions/Runの設定を通じて管理されます 47。
4.4. Cloudflare Workersからの移行容易性
概念的な類似性: FaaSモデルはWorkersとある程度似ています。
ランタイムの違い: WorkersはエッジのV8分離環境で動作しますが、FunctionsはサーバーサイドのNode.jsコンテナで動作します 48。HonoにはNode.jsアダプタが必要です 9。
APIマッピング: Cloudflare固有のAPI (KV, D1, R2など) をGCPの同等機能 (Firestore, Cloud SQL, Cloud Storage, Memorystoreなど) に置き換える必要があります 1。これが主要な移行作業となる可能性が高いです。Honoアプリケーションのコアロジック自体は移植可能かもしれませんが、プラットフォームサービス（ストレージ、データベースなど）との統合点は大幅な変更が必要です。移行の容易さは、APIがCloudflareネイティブ機能にどれだけ依存しているかに大きく左右されます 1。
5. 評価：Hono.js API向けCloud Run5.1. メリット
柔軟性と制御: 任意のコンテナを実行でき、任意の言語/ライブラリ/バイナリを使用できます 3。コンテナ環境を完全に制御できます 3。
スケーラビリティ: 設定可能な同時実行数、最小/最大インスタンス数を持つ堅牢な自動スケーリングを提供します 4。最小インスタンスを設定することで、コールドスタートのパフォーマンスを改善できる可能性があります 14。
コスト効率: 持続的または高トラフィックの場合、Functionsよりもコスト効率が高いことが多いです 6。
ソースデプロイ: ソースコードから直接デプロイするオプションがあり、コンテナ化を簡素化します 3。
長いタイムアウト: Cloud Functionsよりも長いリクエスト処理時間 (最大60分) をサポートします 6。
5.2. デメリット
わずかに高い複雑性: ソースデプロイを使用する場合でも、コンテナの概念を理解する必要があります (内部的にコンテナ化されるため) 3。手動のDockerfileは最大限の制御を提供しますが、複雑さが増します 16。
運用オーバーヘッド (カスタムコンテナ使用時): コンテナイメージのビルドと管理は、Functionsと比較して開発ワークフローにステップを追加します 6。
5.3. コンテナ化：ソースデプロイ vs. コンテナデプロイ
ソースデプロイ: GCP Buildpacksが自動的にコンテナを作成します 3。よりシンプルで、標準的なNode.jsアプリに適しています。
コンテナデプロイ: 独自のDockerfileを提供し、環境、依存関係、ビルドプロセスを完全に制御します 16。カスタムランタイムや複雑なセットアップに必要です。
ソースデプロイとコンテナデプロイの選択は、シンプルさと制御のトレードオフを表します。ソースデプロイは、標準的なアプリケーションに対してCloud Runへの参入障壁を下げ、Functionsとほぼ同等の容易さを提供しつつ、Runプラットフォームの基本的なパワーと柔軟性を維持します 3。一方で、コンテナデプロイは最大限のカスタマイズを可能にしますが、Dockerに関する知識が必要です。ユーザーは、まずシンプルさのためにソースデプロイから始め、後でより多くの制御が必要になった場合にコンテナデプロイに移行することができます。
5.4. 設定とセットアップ
Node.js環境内で@hono/node-serverアダプタが必要です 9。
gcloud run deploy コマンドを使用し、--source または --image フラグを指定してデプロイします 16。
Honoサーバーのセットアップで正しいポート (Cloud Runのデフォルトは通常8080) を設定する必要があります 16。
環境変数とシークレットは、Cloud Runサービス構成を通じて管理されます 53。
5.5. Cloudflare Workersからの移行容易性
ランタイムの違い: Cloud Functionsと同様です (エッジV8 vs. サーバーサイドNode.jsコンテナ)。Node.jsアダプタが必要です 9。
APIマッピング: Cloud Functionsと同じ課題です – Cloudflare固有のAPIを置き換える必要があります 1。
制御: Hono APIがCloud Functionsでは容易に利用できない特定のシステム依存関係や構成を必要とする場合、Cloud Runのより大きな環境制御が有利になる可能性があります。Cloud Runは、アプリケーションがより標準的なNode.jsサーバー環境から恩恵を受ける場合や、コンテナ内で管理しやすい依存関係/構成を必要とする場合に、わずかにスムーズな移行パスを提供する可能性があります。ただし、APIマッピングの主要な課題はFunctionsと同じです 1。
6. 評価：静的サイト向けCloud Storage + Cloud CDN6.1. メリット
スケール時のコスト効率: CDNの段階的料金設定により、高トラフィックサイトではFirebase Hostingよりもデータ下り転送コストが低くなる可能性があります 23。
詳細な制御: ストレージ、キャッシュ (ヘッダー/CDNポリシー経由) 24、およびロードバランシングに対するきめ細かな制御が可能です。
統合: ネイティブなGCPサービスであり、Logging、Monitoringなどの他のGCPサービスとうまく統合します。
6.2. デメリット
複雑性: 複数のコンポーネント (バケット、権限、CDN、ロードバランサー、SSL証明書) の手動設定と構成が必要です 20。運用オーバーヘッドが高くなります 4。
HTTPSコスト/設定: カスタムドメインHTTPSにはロードバランサーが必要であり、月額固定費 (約$15-18) が追加されます 22。設定もより複雑です。
開発者エクスペリエンス: Firebase Hostingと比較して、デプロイが効率的ではありません。アトミックデプロイ、プレビューチャネル、簡単なロールバックなどの機能が標準では提供されません (カスタムスクリプトが必要)。
6.3. 設定とセットアップ
GCSバケットを作成し、パブリックアクセス用に構成します 20。
バケットのウェブサイト構成で index.html および 404.html ページを設定します 20。
External HTTPS Load Balancerをセットアップします 21。
GCSバケットを指すバックエンドバケットを構成します 21。
バックエンドバケットでCloud CDNを有効にします 21。
フロントエンド (IPアドレス、HTTPSプロトコル、SSL証明書 - Googleマネージドまたは自己管理) を構成します 21。
ドメインをロードバランサーIPに向けるようにDNS Aレコードを更新します 22。
6.4. Cloudflare Pagesからの移行容易性
ビルド出力: Viteのビルド出力 (dist ディレクトリ) をGCSバケットにアップロードする必要があります 20。
構成マッピング: Cloudflare Pagesで構成されたカスタムヘッダーやリダイレクトを、ロードバランサールールやGCSメタデータを使用して再現する必要があります。Cloudflareの _headers / _redirects ファイル 1 は手動での変換が必要です。
デプロイワークフロー: Cloudflare PagesのGit統合を置き換えるために、新しいデプロイプロセス (例: gsutil やクライアントライブラリを使用するCI/CDパイプライン) を設定する必要があります 2。
移行には、単にファイルを移動するだけでなく、関連する構成 (HTTPS、CDN、リダイレクト、ヘッダー) とデプロイワークフローを再作成する必要があります。これは、Firebase Hostingへの移行と比較して、大幅に手作業が多くなります 1。Cloudflare Pagesはビルド、デプロイ、CDN、SSL、リダイレクト、ヘッダーを統合して提供しますが 2、CS+CDNではStorage、CDN、LB、SSL、DNSを個別に設定する必要があります 20。
7. 評価：静的サイト向けFirebase Hosting7.1. メリット
シンプルさとDX: Firebase CLIによる非常に簡単なセットアップとデプロイ 38。マネージドサービスであり、運用オーバーヘッドは最小限です 4。
統合機能: 組み込みのグローバルCDN、カスタムドメインに対する自動無料SSL、アトミックデプロイ、ロールバック、プレビューチャネル 32。
コスト (低～中トラフィック): 寛大な無料利用枠により、多くのサイトで無料または非常に安価になる可能性があります 32。CS+CDN+LB設定の固定ロードバランサーコストを回避できます 32。
Firebaseエコシステム: 他のFirebaseサービス (Functions, Firestore, Auth) とのシームレスな統合 35。
7.2. デメリット
コスト (高トラフィック): 無料枠を超えたデータ転送コスト ($0.15/GB) は、非常に大規模なスケールではCloud CDNの段階的料金設定よりも高くなる可能性があります 37。
制御の制限: CDNキャッシュ動作や基盤となるインフラストラクチャに対する制御は、CS+CDN+LBと比較して粒度が粗くなります。
7.3. 設定とセットアップ
Firebase CLIをインストールし、ログイン (firebase login)、プロジェクトを初期化 (firebase init hosting) します 38。
firebase.json を構成します：パブリックディレクトリ (dist for Vite) を指定し 38、リライト (SPAルーティング用)、リダイレクト、ヘッダーを設定します 42。
firebase deploy --only hosting を使用してデプロイします 38。
Firebaseコンソール経由でカスタムドメインを接続し、提供されるDNSレコード (検証用TXT、接続用Aレコード) を設定します 37。SSLは自動的にプロビジョニングされます 35。
7.4. Cloudflare Pagesからの移行容易性
ビルド出力: 同様のプロセス：Firebase HostingがViteのビルド出力 (dist) ディレクトリを指すようにします 38。
構成マッピング: Cloudflareの _headers / _redirects 1 を firebase.json 形式に変換します 43。Firebase Hostingは同様の概念をサポートしています。
デプロイワークフロー: Cloudflare PagesのGitデプロイメントを firebase deploy コマンドに置き換えます。CI/CDへの統合も容易です 2。
Firebase Hostingは、開発者エクスペリエンスと統合機能 (CDN、SSL、構成ファイル) に同様の焦点を当てているため、Cloudflare Pagesからの移行パスとしてはるかに直接的です。コアコンセプトのマッピングがより密接に行えます 1。
7.5. GCPプロジェクト統合
Firebaseプロジェクトは実質的にGCPプロジェクトです 40。Firebaseプロジェクトを作成すると、自動的にGCPプロジェクトが作成されます。
Firebase HostingはGCPインフラストラクチャ (バックエンドストレージとしてのCloud Storage 40、GoogleのCDN 35) を活用します。
同じプロジェクト内で他のGCPサービス (リライト経由でのCloud Functions、Cloud Runなど) をシームレスに使用できます 35。
GCPコンソールを通じて統合された請求とIAM管理を提供します。
8. APIと静的サイトの連携分析8.1. CORS設定
要件: フロントエンド (Firebase/CS+CDNでホスト) は、API (Functions/Runでホスト) にリクエストを行う必要があります。このオリジン間の対話には適切なCORS設定が必要です。
Hono.js API (Functions/Run): CORSは、Honoアプリケーション内でそのCORSミドルウェアを使用して処理する必要があります 58。設定には、許可されるオリジン (フロントエンドドメイン)、メソッド、ヘッダーなどの指定が含まれます 58。
Cloud Run特有の考慮事項: Cloud Runサービスが認証を必要とするか、内部専用の場合、CORSプリフライト OPTIONS リクエストが失敗する可能性があります 61。APIエンドポイントに対して未認証アクセスを許可するか、API Gateway/IAPを適切に構成する必要があります。Firebase Hostingのリライトを使用してCloud Runへのリクエストをプロキシすると、ブラウザ側のCORS問題が解消される場合があります 62。
Cloud Functions特有の考慮事項: 認証とトリガーに関して同様の考慮事項が適用されます。CORSヘッダーは、Honoミドルウェア経由か、Honoアダプタを使用しない場合はFunctions Frameworkヘルパー経由で、関数レスポンスで正しく設定する必要があります 64。
Cloud Storage (CORSが必要なアセット直接配信の場合): GCSバケット自体に gsutil またはAPIを使用してCORS構成を設定する必要があります 67。これは、フロントエンドがAPIを呼び出すだけの場合はあまり関係ありませんが、フロントエンドドメイン上のスクリプトが 別の GCSバケット/ドメインからアセット (例: フォント) を直接フェッチする場合は重要です 72。
Cloud CDNとCORS: Cloud CDNは、オリジン (Hono APIまたはGCSバケット) によって設定されたCORSヘッダーを含むレスポンスをキャッシュします 73。それ自体がCORSヘッダーを追加することはありません。オリジンのCORS設定が正しくないと、必要なヘッダーなしでレスポンスがキャッシュされる可能性があります 73。オリジンでCORS設定を変更した後、キャッシュの無効化が必要になる場合があります 69。バケットのCORS設定変更は、CDNキャッシュに即座には影響しません 69。
Firebase HostingとCORS: Firebase Hosting によって 提供される静的ファイルの場合、CORSヘッダーは firebase.json で設定できます 42。Functions/Runへのリライトを介してプロキシされるリクエストの場合、CORSヘッダーは バックエンドの関数/サービス によって設定される必要があります 65。Firebase Hosting自体は、プロキシされたレスポンスにCORSヘッダーを追加しません。
CORSは主にAPIのアプリケーションレベルの問題であり (Honoで処理する必要がある)、インフラストラクチャの選択は主にフロントエンドドメインの定義方法 ( Origin ヘッダーに影響) と、プリフライトリクエストがAPIに正しく到達できるかどうか (認証/ネットワーク障壁) に影響します。Firebase Hostingのリライトは、APIを同一オリジンに見せることで、潜在的な簡素化を提供します。ブラウザは同一オリジンポリシーを強制するため 69、異なるドメインからAPIを呼び出すフロントエンドJSはAPIからのCORSヘッダーを必要とします 58。したがって、インフラに関係なくHonoでCORSを処理することが不可欠ですが、Firebase HostingのリライトはブラウザのCORSチェックの必要性をなくす可能性があるため、最もシンプルな統合パスを提供します 62。
8.2. APIエンドポイント設定
フロントエンドのニーズ: Vite+ReactアプリはHono.js APIのURLを知る必要があります。
Functions/Run直接URL: APIをFunctions/Runにデプロイすると、直接的な *.run.app または *.cloudfunctions.net URLが提供されます。これはViteビルドプロセスで環境変数として設定できます。
カスタムドメイン: カスタムドメインをCloud Runサービス (またはRun経由のFunction) にマッピングできます。
Firebase Hostingリライト: Firebase Hostingドメイン上のパス (例: /api/*) をバックエンドのFunction/Runサービスにリライトするように firebase.json を構成します 43。フロントエンドは自身のドメイン上の /api/* を呼び出します。これにより、フロントエンドの構成が簡素化され、CORSも潜在的に簡素化されます 62。
Cloud Storage + CDN + LB: ロードバランサーがフロントエンドのパブリックIP/ドメインを提供します。APIは別のドメイン (CORSが必要) に置くか、パスベースルーティングを使用して同じロードバランサー経由でルーティングする (より複雑なLB設定が必要) ことができます。
Firebase Hostingのリライトは最もシームレスな統合エクスペリエンスを提供し、APIを静的サイトと同じドメインの一部であるかのように見せることで、フロントエンドの構成とCORS管理の両方を簡素化します 43。
9. 推奨事項と結論9.1. 主要な調査結果の要約これまでのセクションでの評価に基づき、各サービス組み合わせの長所と短所を要約します。シンプルさと開発者エクスペリエンス (Firebase Hosting, Cloud Functions/Run Source Deploy) と、制御性と大規模スケールでのコスト効率 (Cloud Storage+CDN+LB, Cloud Run Container Deploy) の間にはトレードオフが存在します。また、Cloudflare固有のAPIをGCPの同等機能にマッピングする移行作業の重要性を強調します。9.2. 最適な組み合わせの提案
API (Hono.js): Cloud Run が最適と考えられます。

理由: Web APIに対して、Cloud Functionsよりも優れた柔軟性、制御、スケーラビリティ構成、そして潜在的により良いコストパフォーマンスを提供します 4。ソースデプロイは簡単な開始点を提供し 3、コンテナデプロイは将来のカスタマイズを可能にします 16。Hono.jsはCloud Run上で良好に動作します 16。Workersから移行する可能性のある複雑なAPIに対して、より標準的なNode.js環境を提供し、整合性が取れています 1。


静的サイト (Vite+React): Firebase Hosting が推奨されます。

理由: CS+CDN+LBと比較して、セットアップと管理が大幅に簡素化されます 32。カスタムドメインに対する無料CDNと自動SSLが含まれており、LBコストを回避できます 32。Firebase CLIによるデプロイ、プレビュー、ロールバックなど、優れた開発者エクスペリエンスを提供します 35。リライト機能によるCloud Run APIとのシームレスな統合は、フロントエンド構成とCORSを簡素化します 43。無料利用枠が寛大であり、トラフィックが極端に高くない限り、コストはおそらく低くなります 32。Cloudflare Pagesの概念からの直接的な移行パスを提供します 1。


9.3. 提案理由この組み合わせ (Cloud Run + Firebase Hosting) が最適である理由は以下の通りです。
コスト: Firebase Hostingの無料利用枠を活用し、CS+CDNの必須LBコストを回避するため、最もコスト効率の高い出発点となる可能性が高いです。Cloud Runの料金設定も競争力があります 6。
パフォーマンス: 両サービスともGoogleのグローバルインフラストラクチャ (Firebase Hosting経由のCDN、Cloud Run経由のスケーラブルなコンピューティング) を活用します。Cloud Runの最小インスタンスはAPIのコールドスタートを緩和できます。
運用負荷: Firebase Hostingは静的サイトの運用負担を大幅に削減します 4。Cloud Run (特にソースデプロイの場合) はAPIにとって管理可能です 3。全体として、CS+CDN+LB + Cloud Run/Functionsよりも運用上の複雑さが低いです。
移行容易性: Firebase HostingはCloudflare Pagesからのよりスムーズな移行パスを提供します 1。Cloud RunはHono APIに柔軟な環境を提供し、主な課題はCF APIマッピングです (Run/Functions共通) 1。Firebase HostingのリライトはAPI統合を簡素化します 62。
将来性: この設定は十分にスケールします。Cloud RunはかなりのAPI負荷を処理できます。Firebase Hostingは、将来の機能追加のために、より広範なGCP/Firebaseエコシステムと統合します 35。APIの複雑さが増した場合、カスタムコンテナを備えたCloud Runが必要な制御を提供します 16。
9.4. 最終的な移行に関する考慮事項
APIリファクタリング: Cloudflare Worker固有のAPI呼び出し (KV, D1など) を特定し、GCPの同等機能を使用するようにリファクタリングすることを優先します 1。
環境変数/シークレット: Cloud Runおよび潜在的にViteビルドプロセスでの構成とシークレットの管理計画を立てます 47。
CI/CD: Hono APIをCloud Runにデプロイ (gcloud run deploy) し、ViteサイトをFirebase Hostingにデプロイ (firebase deploy) するための新しいCI/CDパイプラインを設定します。
テスト: 移行後、CORSの動作を含む統合アプリケーションを徹底的にテストします。Firebase Hostingのプレビューチャネルを活用します。
ドメイン/DNS: カスタムドメインをFirebase Hostingに向け、リライトを使用しない場合はCloud Runに別のドメイン/サブドメインを向けるために必要なDNS変更を計画します。
本レポートが、CloudflareからGCPへの移行における最適なサービス選択の意思決定に貢献できれば幸いです。